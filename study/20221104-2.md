> 20221104 기록 : 문제 풀이 복습

### 반정규화

|  기법분류   |      기법       |                                                내용                                                 |
| :---------: | :-------------: | :-------------------------------------------------------------------------------------------------: |
| 테이블병합  |     1:1관계     |                                            1:1관계 통합                                             |
|             |     1:M관계     |                                            1:M관계 통합                                             |
|             |  슈퍼/서브타입  |                                         슈퍼/서브관계 통합                                          |
| 테이블 분할 |    수직분할     |                           컬럼 단위 테이블을 1:1 분리, 디스크I/O 분산처리                           |
|             |    수평분할     | 행 단위로 테이블 쪼갬, 행 단위 집중 발생되는 트랜잭션 분석, 디스크 I/O 및 데이터 접근의 효율성 높임 |
| 테이블 추가 | 중복테이블 추가 |                            다른 업무거나 서버가 다를 때, 원격 조인 제거                             |
|             | 통계테이블 추가 |                                 SUM, AVG 미리 계산, 조회 성능 향상                                  |
|             | 이력테이블 추가 |                   마스터 테이블에 존재하는 레코드가 이력테이블에도 중복하여 존재                    |

### 정규화

|    구분    |                       설명                        |
| :--------: | :-----------------------------------------------: |
| 제 1정규화 |      테이블 속성 하나에 속성값 여러개일 경우      |
| 제 2정규화 | 복합키인데, 특정 컬럼에만 종속된 컬럼 존재할 경우 |
| 제 3정규화 | 기본키 말고 일반키에 의지하는 이행 함수 종속 제거 |

### 3번 슈퍼/서브타입 데이터 모델의 변환 타입 비교

|              구분              |         OneToOne Type          |                 Plus Type                 |           Single Type           |
| :----------------------------: | :----------------------------: | :---------------------------------------: | :-----------------------------: |
|              특징              |        개별테이블 유지         |           슈퍼+서브타입 테이블            |          하나의 테이블          |
|             확장성             |              우수              |                   보통                    |              나쁨               |
|            조인성능            |              나쁨              |                   나쁨                    |              우수               |
|           I/O량 성능           |              좋음              |                   좋음                    |              나쁨               |
|           관리용이성           |            좋지않음            |                 좋지않음                  |            좋음(1개)            |
| 트랜잭션 유형에 따른 선택 방법 | 개별 테이블로 접근이 많은 경우 | 슈퍼+서브 형식으로 데이터를 처리하는 경우 | 전체를 일괄적으로 처리하는 경우 |

### 도메인 : 속성이 가질 수 있는 값의 (허용)범위

### 제 3정규화 : 주식별자를 제외한 칼럼 간의 종속성을 확인 해 종속성이 있으면 분할하는 과정

### 엔터티

|      종류       |                         설명                          |
| :-------------: | :---------------------------------------------------: |
|   독립 엔터티   |     사람,물건,장소 등 현실세계에 존재하는 엔터티      |
| 업무중심 엔터티 |         트랜잭션이 실행되면서 발생하는 엔터티         |
|   종속 엔터티   | 주로 1차 정규화로 인해 중심엔터티로부터 분리된 엔터티 |
|   교차 엔터티   |            N:M 관계 해소 목적 (N:M -> 1:M)            |

유형/무형 기준 분류

|    종류     |                            설명                            |
| :---------: | :--------------------------------------------------------: |
| 유형 엔터티 | 물리적 형태 O, 안정적이고 지속적으로 사용 - 사업,물품,강사 |
| 개념 엔터티 |     개념적으로 사용 O, 물리적 형태 X - 조직, 보험상품      |
| 사건 엔터티 |       업무 수행시 발생하는 엔터티 - 주문, 청구, 미납       |

발생시점에 따른 분류
| 종류 | 설명 |
| :---------: | :--------------------------------------------------------: |
| 기본 엔터티 | 독립적으로 생성 = 키엔터티|
| 중심 엔터티 | 기본엔터티로부터 발생했고, 행위엔터티를 생성함 |
| 행위 엔터티 | 2개 이상의 엔터티로부터 발생한 것, 지속적으로 정보가 추가되고 변경됨 |

### ERD 작성 절차

엔터티 그림 -> 배치 -> 관계설정 -> 관계명기술 -> 참여도 기술 -> 관계 필수여부 기술

### 식별자

| 식별자 분류 |   식별자    |                                             설명                                              |
| :---------: | :---------: | :-------------------------------------------------------------------------------------------: |
| 대표성여부  |  주식별자   |              각 행을 구분 O, 타 엔터티와 참조관계연결 가능 - 사원번호, 고객번호               |
|             | 보조식별자  |                    각 행을 구분 O, but 참조관계연결 불가능 - 주민등록번호                     |
| 스스로 생성 | 내부식별자  |                          엔터티 내부에서 스스로 만들어짐 - 고객번호                           |
|             | 외부식별자  |                     타 엔터티로부터 받아온 식별자 - 주문엔터티의 고객번호                     |
|  속성의 수  | 단일 식별자 |                              하나의 속성 - 고객엔터티의 고객번호                              |
|             | 복합 식별자 |                     둘 이상의 속성 - 주문상세엔터티의 주문번호 + 상세순번                     |
|  대체 여부  | 본질 식별자 |                           업무에 의해 만들어지는 식별자 - 고객번호                            |
|             | 인조식별자  | 본질 식별자가 복잡해서 인위적으로 만든 식별자 - 주문엔터티의 주문번호(고객번호+주문번호+순번) |

### 순위함수 RANK(), DENSE_RANK(), ROW_NUMBER() / NTILE() / PARTITION BY

RANK() -> 중복 등수 건너뜀 (1위, 1위, 3위, 4위)  
DENSE_RANK() -> 중복 등수 안 건너뜀 (1위, 1위, 2위, 2위)  
ROW_NUMBER() -> 중복 허용X (1위, 2위, 3위, 4위)  
NTILE(숫자) -> 숫자만큼 등분  
PARTITION BY -> 속성 별로 순위 매기기
e.g. RANK() OVER (PARTITION BY job ORDER BY salary DESC) RABK등수

### NVL, NVL2, NULLIF, COALESCE

- NVL(col1, 대체값) === ISNULL(col1, 대체값)
  - col1이 NULL이면 대체값 출력
- NVL2(col1, 대체값, 결과2)
  - col1이 NULL이면 대체값 출력, NOT NULL 이면 결과2 출력
- NULLIF(v1, v2)
  - v1과 v2가 같으면 NULL 출력, 다르면 v1 출력
- COALESCE(v1,v2,...,vn)
  - NULL이 아닌 가장 첫번째 값 출력

### SORT MERGE JOIN

- 해당 테이블의 인덱스가 없을 때 수행, 테이블을 정렬한 후 정렬된 테이블을 병합함며 JOIN 실행

### CONNECT BY

- Oracle 이 지원
- 계층형 구조 탐색

CONNECT BY (PRIOR A = B)

- B가 A보다 앞!

CONNECT_BY_ROOT : 계층형 쿼리에서 최상위 행 반환
CONNECT_BY_ISLEAF : 최하위 자식 행이면 1, 아니면 0을 반환하는 의사컬럼

> 추가로 알아두기, 정렬 시 계층형 구조를 보존하려면 ORDER SIBLINGS BY 사용!!  
> 형제끼리 정렬 수행함  
> ( = ORDER SIBLINGS BY 수행하면 전체 테이블이 아닌 계층형으로 된 데이터 기준으로 정렬됨)

### ROLLUP / CUBE / GROUPING SET

ROLLUP(a,b)  
-> a+b 별, a별
-> 순서 상관 O
CUBE(a,b)  
-> a+b 별, a별, b별, 전체 별
GROUPING SET(a,b)
-> a별, b별

### SCAN

UNIQUE SCAN : 유일한 값 하나 찾기 (한개의 행)
RANGE SCAN : 어떠한 조건에서 한 범위 찾기
FULL SCAN : 전체 데이터 (전체 행)

### CHAR 와 VARCHAR의 차이

같은 값에 길이만 다를 경우

- CHAR : 짧은 쪽에 스페이스를 추가하여 같은 값으로 판단함
- VARCHAR : 다른 값으로 판단함

### 정렬 내림차순/ 오름차순

내림차순 DESC / 오름차순 ASC

### VIEW

- 뷰는 실제 데이터를 갖고 있지 않지만 테이블 역할을 함(=> 가상테이블)
  독립성 : 테이블 구조가 변경돼도 뷰를 사용하는 응용 프로그램은 변경 안해도 됨
  편리성 : 복잡한 질의 단순하게 작성 가능
  보안성 : 숨기고 싶은 정보가 존재할 때, 해당 컬럼을 빼고 뷰를 생성하면 정보를 숨길 수 있음

### SELECT 구에는 GROUP BY절에 있는 칼럼이 그대로 있어야 함

### ALTER

컬럼 수정 : ALTER TABLE ~ MODIFY
컬럼 추가 : ALTER TABLE ~ ADD
컬럼 삭제 : ALTER TABLE ~ DROP COLUMN

테이블 삭제 : DROP TABLE ~

### 분산 데이터베이스

- 장점

  - 데이터베이스의 신뢰성과 가용성이 높다
  - 병렬처리로 빠름
  - 시스템 용량 확장이 쉬움

- 단점
  - 여러 네트워크를 통해 분리되어 관리와 통제 어려움
  - 보안관리 어려움
  - 데이터 무결성 관리 어려움
  - 데이터베이스 설계 복잡함

### HASH JOIN

- 조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용 가능
- 해시 함수를 이용해 조인을 수행하기 때문에 '='로 수행하는 동등조건에만 사용가능
- 해시 함수가 적용될 때 동일한 값을 항상 같은 값으로 해싱됨이 보장됨
- 해시조인 작업을 수행하기 위해 해시 테이블을 메모리에 생성해야 함
- 메모리에 적재할 수 있는 영역의 크기보다 커지면 임시 영역(디스크)에 해시 테이블을 저장함
- 해시조인을 할 대는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋음
- 선행 테이블을 build input이라 하며, 후행 테이블을 Prove input이라 함

### 숫자형 함수

ROUND 반올림
ABS 절댓값
FLOOR 내림
TRUNC 소수점 버림
CEIL 올림
MOD 나머지
SIGN 숫자가 양수면 1, 음수면 -1, 0이면 0반환

### ROLE (조심)

- 데이터 베이스에서 OBJECT(테이블, 프로시저, 뷰) 등의 권한을 묶어서 관리할 수 있음

### EXISTS

- 하위 쿼리가 하나 이상의 레코드를 반환하는 경우 TRUE, 아닌경우 FALSE
- 속도가 빠름
