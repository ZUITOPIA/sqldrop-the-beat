> 20221104 기록 : 문제 풀이 강의 마지막 파트 기록

### Window 함수

- 레코드(행) 사이의 관계를 쉽게 정의하기 위한 함수
- 사용 기본 구조 : WINDOW_FUNCTION () OVER ()

WINDOW_FUNCTION : 윈도우 함수
ARGUMENTS : 인수(작업 대상)
PARTITION BY : 테이블의 레코드들을 쪼개는 기준
ORDER BY : 쪼개진 레코드들 내에서 혹은 전체 테이블에서 레코드들을 정렬하는 방법
WINDOWING : 함수의 연산 대상이 되는 레코드의 범위를 정함

사용 방법 >

        SELECT WINDOW_FUNCTION (ARGUMENTS) OVER ([PARTITION BY 컬럼명][order by 컬럼명][WINDOWING])

        FROM 테이블명;

### WINDOW_FUNCTION 종류

- 집계함수 : COUNT, SUM, MIN, MAX, AVG 등
- RANK 함수 : RANK(), DENSE_RANK(), ROW_NUMBER()
- 비율 관련 함수 : PERCENT_RANK, NTILE(n), CUME_DIST
- 행 순서 함수 : FIRST_VALUE, LAST VALUE, LAG(컬럼명, 레코드 위치 차이값), LEAD(컬럼명, 레코드 위치 차이값, null일 경우 대체 값)
- WINDOWING
  - RANGE BETWEEN 시작 AND 끝 : 범위 지정
  - BETWEEN a AND b : a부터 b까지 윈도우가 적용됨
  - UNBOUNDED PRECEDING : 첫번째 행
  - UNBOUNDED FOLLOWING : 마지막 행
  - CURRENT ROW : 현재 행

### (Q) 순위 함수에 대한 설명으로 틀린 것을 고르시오.

보기 1) 순위함수를 사용할 경우 ORDER BY 절은 입력하지 않아도 된다.
보기 2) ROW_NUMBER 함수는 동일한 순위가 부여되지 않는다.
보기 3) RANK 함수는 동일한 값에 대해서 동일한 순위를 부여하며, 동일한 등수인 레코드가 많을 경우 등수가 생략될 수 있다.
보기 4) DENSE_RANK 함수는 RANK 함수와 흡사하지만 동일한 순위를 하나의 건수로 취급하며, 동일한 등수인 레코드가 많더라도 등수가 생략되지 않는다.

정답 : 1번
설명 : 순위가 매겨진다고 해서 자동으로 정렬되는 것은 아니기때문에 ORDER BY를 사용하여 오름차순, 내림차순 출력 함

### (Q) 아래의 결과를 출력하는 SQL문을 완성하시오.

결과
| 매장코드 | 지역명 | 메뉴명 | 판매량 | 판매순위 |
| :------: | :----: | :------: | :----: | :------: |
| 101 | 서울 | 연어스시 | 400 | 1 |
| 101 | 서울 | 참치스시 | 400 | 1 |
| 101 | 서울 | 와규 | 300 | 2 |
| 102 | 부산 | 연어스시 | 600 | 1 |
| 102 | 부산 | 튀김 | 300 | 2 |

SELECT 매장코드, 지역명, 메뉴명, 판매량, [ ] AS 판매순위  
FROM 판매

정답 : DENSE_RANK () OVER (PARTITION BY 지역명 ORDER BY 판매량 DESC])

결과
| 매장코드 | 지역명 | 메뉴명 | 판매량 | col1 |
| :------: | :----: | :------: | :----: | :------: |
| 101 | 서울 | 연어스시 | 400 | 1100 |
| 101 | 서울 | 참치스시 | 400 | 1100 |
| 101 | 서울 | 와규 | 300 | 1100 |
| 102 | 부산 | 연어스시 | 600 | 900 |
| 102 | 부산 | 튀김 | 300 | 900 |

SELECT 매장코드, 지역명, 메뉴명, 판매량, [] OVER (PARTITION BY 지역명) col1  
FROM 판매

정답 : SUM(판매량)

### SQL 문의 결과 반환되는 ㄱ, ㄴ 값을 구하시오.

| 매장코드 | 지역명 |  A  |  B  |
| :------: | :----: | :-: | :-: |
|    A     |  서울  |     |     |
|    B     |  부산  |     |     |
|    C     |  부산  | ㄱ  | ㄴ  |
|    D     |  부산  |     |     |
|    E     |  부산  |     |     |

SELECT 매장코드, 지역명, LAG(매장코드, 2) OVER (ORDER BY 매장코드 DESC) A  
, LEAD(매장코드, 2) OVER (PARTITION BY 지역명 ORDER BY 매장코드) B

정답 : ㄱ (E), ㄴ (E)

### (Q) 윈도우 함수를 활용하여 매출액 컬럼의 첫 행에서부터 현재 행까지 누적 합을 구하기 위한 SQL 문이다. 아래의 빈칸을 채우시오.

SELECT 지역명, 매장코드, 매출일자, SUM(매출액) OVER (PARTITION BY 매장코드 ORDER BY 매출일자 ROWS BETWEEN [] AND CURRENT ROW) sum_sales  
FROM 판매
WHERE EXTRACT(YEAR FROM 매출일자) = 2021  
ORDER BY 매출일자

정답 : UNBOUNDED PRECEDING

### 테이블 파티션

- 대용량의 테이블을 여러 개의 데이터 파일에 분리하여 저장하는 것
- 물리적으로 분리된 데이터 파일에 저장되어 입력/수정/삭제/조회 성능이 향상되고, 독립적 관리가 가능
- 조회의 범위를 줄이는 효과가 있어 성능이 향상됨

테이블파티션 종류

- RANGE PARTITION
  - 값의 범위를 기준으로 파티션을 나눠 저장
- LIST PARTITION
  - 특정 값을 기준으로 분할
- HASH PARTITION
  - 데이터베이스 관리 시스템이 자체적으로 해시함수를 사용해 분할하고 관리하는 방식

### (Q) 계층형 조회 : 아래의 SQL을 수행한 결과 첫번째 행의 값을 기입하시오.

| col1 | col2 | col3 |
| :--: | :--: | :--: |
|  11  |  10  |  10  |
|  12  |  11  |  12  |
|  13  |  12  |  13  |
|      |  13  |  15  |

SELECT col3  
FROM 조직구조  
START WITH col1 IS NULL  
CONNECT BY PRIOR col1 = col2 ;

| col1 | col2 | col3 |
| :--: | :--: | :--: |
|      |  13  |  15  |
|  13  |  12  |  13  |
|  12  |  11  |  12  |
|  11  |  10  |  10  |

정답 : 15

### Optimizer

- SQL 실행계획을 수립하고, SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어
- 같은 SQL문이어도 어떻게 실행하냐에 따라 성능이 달라짐(소요시간, 자원사용량 등)
  => SQL 문을 분석한 후 일정한 기준을 통해 실행계획을 세워야함, 이 때 옵티마이저 사용!

순서 >  
SQL 문 작성 -> Parsing(문법 검사, 구문 분석) -> 옵티마이저(비용 기반/규칙 기반) -> 실행계획(PLAN_TABLE 저장) -> SQL 실행

옵티마이저 : 비용 기반(default) / 규칙 기반

- 비용 기반 옵티마이저

  - 시스템 통계와 오브젝트 통계를 통해 해당 SQL 문 실행에 대한 총 비용을 계산
  - 총 비용이 가장 적은 쪽으로 실행 계획 수립

- 규칙 기반 옵티마이저

  - 15가지 우선순위를 기준으로 실행계획을 수립

### INDEX

- 데이터의 목차, 원하는 데이터를 빠르게 조회할 수 있게 함  
  (인덱스는 인덱스 키를 기준으로 정렬되어있어 탐색이 빠름)
- Primary Key(기본키)는 자동적으로 INDEX가 됨
- 하나의 테이블에 여러 개의 인덱스를 생성할 수 있고, 하나의 인덱스는 여러 컬럼으로 구성될 수 있음

INDEX Unique SCAN
=> 인덱스 키 값이 중복되지 않을 때 해당 키를 통해 탐색
INDEX Range SCAN
=> 특정 범위를 조회하는 WHERE 문을 사용하여 해당 영역을 스캔
INDEX Full SCAN
=> 인덱스의 처음부터 끝까지 모두 스캔

### (Q) 옵티마이저 말문제 - 다음 설명 중 적절한 것을 고르시오.

보기 1) 규칙 기반 옵티마이저에서 가장 높은 우선순위는 전체 테이블 스캔방식이다. X  
보기 2) 인덱스는 오름차순으로 생성/정렬된다. X  
보기 3) 인덱스 범위 스캔은 항상 복수의 결과를 출력한다. X  
보기 4) 같은 SQL 문이더라도 실행계획이 다르면 결과가 다르다. X  
보기 5) 자주 변화하는 속성을 인덱스로 설정하는 것은 좋지 않다. O  
보기 6) 보조인덱스는 중복 데이터 입력이 불가능하다. X  
보기 7) 인덱스를 통한 스캔은 항상 전체 테이블 스캔보다 효율적이다. X  
보기 8) 비용 기반 옵티마이저는 항상 인덱스 스캔이 유리하다고 판단한다. X  
보기 9) 파티션 테이블은 파티션에 대한 인덱스를 생성할 수 있다. O  
보기 10) 인덱스의 수는 데이터의 입력, 삭제, 수정 속도에 영향을 미치지 않는다. X  
보기 11) 인덱스 생성이 가능한 데이터 타입은 VARCHAR와 NUMBER 뿐이다. X  
보기 12) 인덱스 종류는 순차 인덱스, 비트맵, 결합인덱스, 클러스터, 해시인덱스가 있다. O

정답 : 5, 9, 12

설명 >  
보기 1) 일반적으로 전체 테이블 스캔방식이 아닌 ROWID 기반 스캔이 가장 높은 우선순위  
보기 2) 오름차순이 아닌, 내림차순으로 생성 및 정렬됨  
보기 3) 스캔 범위에 따라 단수의 결과 혹은 0건의 결과 출력도 가능함  
보기 4) 실행계획이 다르다고 결과가 다른건 아니고 성능이 다른 것  
보기 5) 삭제, 조회 등의 작업에 있어서 자꾸 변하면 안 됨  
보기 6) UNIQUE 속성을 가진 인덱스가 아니라면 중복도 가능  
보기 7) 랜덤 엑세스의 경우 오히려 전체 테이블 스캔이 유리할 수 있음  
보기 8) 비용 기반으로, 전체 테이블 스캔이 유리할 수도 있음  
보기 9) 파티션 키에 대한 인덱스 생성 가능 -> Global 인덱스라고 부름!  
보기 10) 인덱스의 수가 증가할 경우 속도가 느려질 수 있음  
보기 11) VARCHAR, NUMBER, DATE, CHAR 모두 다 가능  
보기 12) 그렇다

### (Q) 아래에서 설명하는 각 조인의 이름을 기술하시오.

한 테이블 내에서 연관관계를 가진 두 칼럼 간의 조인 - SELF JOIN

서로 연관된 컬럼이 없을 경우 수행하는 조인 - CROSS JOIN

### SELF JOIN

- 한 테이블 내에서 연관관계를 가진 두 칼럼 간의 조인

- 테이블 명과 컬럼명이 모두 일치하기 때문에 꼭 ALIAS를 써줘야 함

        SELECT T1.col1, T2.col1

        FROM 테이블명 T1, 테이블명 T2

        WHERE T1.col1 = T2.col1

### 옵티마이저 조인 3가지

- Nested Loop JOIN

  - 선행 테이블(외부 테이블)을 먼저 조회하여 연결 대상 데이터를 찾고, 그 다음 테이블(내부 테이블)을 연결함
  - 먼저 처리되는 데이터의 양 - 선행테이블의 처리범위에 따라 처리량이 결정됨
  - 선행 테이블의 크기가 작은 것을 찾아야 함
  - 로우들간의 처리, 테이블 간의 처리 모두 순차적으로 일어남
  - 최적의 순서를 찾아주는 것이 중요함
  - _RANDOM ACCESS_ 발생(선행테이블에서 두번째 테이블을 참조할 때 발생)
  - 성능 지연을 줄이기 위해 RANDOM ACCESS가 적게 발생하도록 해야함
  - 선행 테이블 처리범위가 많거나, 연결 테이블에서의 RANDOM ACCESS 범위가 많다면 SORT MERGE JOIN 보다 불리해지는 경우가 있음
  - _INDEX_ 필요, Unique index 시 유리함
  - 온라인 트랜잭션(OLTP) 처리에 유용함

- Sort Merge JOIN

  - 정렬하고 완료되면 병합
  - 데이터 양이 많을 경우 느려짐
  - 데이터 양이 많을 경우 임시 디스크를 사용하기 때문에 성능 저하
  - EQUI JOIN , non-EQUI JOIN 모두 가능

- HASH JOIN
  - 두 테이블 중 작은 테이블을 HASH 메모리에 로딩하고, 두 테이블의 조인 키를 사용하여 해시 테이블을 생성함
  - 두 테이블을 동시 스캔함
  - 선행 테이블에는 작은 데이터가 먼저 와야함
  - 시스템 자원을 최대한 활용 가능하며 너무 많이 사용될 우려도 있음
  - 대용량 처리 빠름
  - EQUI JOIN 에서만 가능
  - INDEX 사용 X

용어를 나타내는 단어로 간단 정리

---

- Nested Loop JOIN
  - 선행 테이블(외부테이블)
  - 순차적
  - RANDOM ACCESS
  - INDEX 필요
  - OLTP(온라인 트랜잭션 처리)
- HASH JOIN
  - HASH 메모리
  - 시스템 자원 활용
  - EQUI JOIN에서만 가능
  - INDEX 사용X

---

### (Q) JOIN 말문제 - 각 문항에 대해 O,X 여부를 판단하시오.

보기 1) Nested Loop JOIN 은 중첩된 반복문과 동일한 형식이다. O  
보기 2) Nested Loop JOIN 은 선행테이블의 조건을 만족하는 경우의 수만큼 반복적으로 수행된다. O  
보기 3) Hash JOIN 은 큰 테이블을 선행테이블로 사용하는 것이 좋다. X  
보기 4) FROM 절이 나열된 모든 테이블에 대해 동시에 JOIN 작업이 발생한다. X (아무리 많아도 2개씩)  
보기 5) Sort Merge JOIN 은 정렬작업이 없어서 정렬이 부담되는 대량 배치 작업에서 유리하다. X  
보기 6) Nested Loop JOIN 에서 랜덤 엑세스가 발생한다. O  
보기 7) 대용량 데이터 조인할 때 후행 테이블에 인덱스가 없을 경우 Nested Loop JOIN은 사용할 수 없다. O (인덱스가 필수)  
보기 8) 조인은 테이블과 테이블 사이에서만 발생한다. X  
보기 9) Sort Merge JOIN 은 n개 테이블을 모두 정렬한 후에 조인을 수행한다. O  
보기 10) Sort Merge JOIN 은 범위 검색이 아닌 Equi join 시 적합한 방식이다. X  
보기 11) 온라인 트랜잭션 처리(OLTP)에 유용한 조인방식은 Nested Loop JOIN이다. O  
보기 12) Hash JOIN 에서는 큰 테이블을 먼저 읽고 Hash Area를 만드는 것이 성능에 유리하다. X  
보기 13) Hash JOIN 은 항상 다른 JOIN 방법에 비해 성능이 우수하다. X

### PL/SQL

- SQL을 확장시켜 다양한 절차적 프로그래밍을 가능하게 한 언어
  - Block 구조 => 기능별로 모듈화 가능
  - Declare 문으로 시작하며, 변수 및 상수 선언하여 사용 가능
  - DML,IF, LOOP 문 등 다양한 절차적 언어 사용
  - Oracle에 내장되어있기때문에 동일한 언어를 사용하는 프로그램과 호환 가능
  - 응용 프로그램의 성능 향상

### PL/SQL 말문제 - 각 문항에 대해 O,X 여부를 판단하시오.

보기 1) PL/SQL 언어로 Procedure, User Defined Function, Trigger 객체를 작성할 수 있다. O  
보기 2) DECLARE, EXCEPTION 문은 필수적이다. X (DECLARE, BEGIN ~ END는 필수, EXCEPTION은 선택)  
보기 3) 변수와 상수를 사용하여 문장에 대입할 수 있다. O  
보기 4) Procedure 내부에 작성된 절차적 코드는 SQL 실행기기가 처리하고, 일반적 SQL 문장은 PL/SQL 엔진이 처리한다. X (절차적 코드 - PL/SQL 엔진이 처리, 일반적인 SQL문장은 SQL 실행기가 처리)

### 분산 데이터베이스

- 장점

  - 데이터베이스의 신뢰성과 가용성이 높다
  - 병렬처리로 빠름
  - 시스템 용량 확장이 쉬움

- 단점

  - 여러 네트워크를 통해 분리되어 관리와 통제 어려움
  - 보안관리 어려움
  - 데이터 무결성 관리 어려움
  - 데이터베이스 설계 복잡함
