> 20221104 기록 : 문제 풀이 강의 기록

### EQUI JOIN / non-EQUI JOIN

EQUI JOIN : 동일한 컬럼을 사용하여 두 릴레이션을 결합  
e.g. A.key = B.key

non-EQUI JOIN: 정확하게 일치하지 않는 컬럼들을 사용하여 두 릴레이션을 결합 ('=' 사용 X)  
e.g. A.key <,>,<=,>= B.key

# CROSS JOIN

- 테이블간 결합의 key가 없는 경우, 아무런 연관이 없는 경우의 조인

T1  
| k1 | k2 |
| :--: | :--: |
| 1 | F |
| 12 | M |
| 3 | F |
| 4 | M |
| 15 | F |

T2  
| 회원코드 | 이름 |
| :--: | :--: |
| 101 | kate |
| 102 | max |
| 103 | amily |

T1의 행 5개 x T2의 행 3개 = 총 15개의 행이 조회됨 -> 비용 엄청나게 발생

사용 : SELECT \* FROM T1 CROSS JOIN T2 ;

# 서브 쿼리

SELECT 안에 SELECT .. > 서브쿼리

        e.g. SELECT 문에 들어가고, 한 행과 한 컬럼만 반환하는 서브쿼리 >> 스칼라 서브쿼리

        SELECT (SELECT * FROM 고객목록 WHERE 거주지 = '서울') A

        JOIN 연락처 B

        ON A.고객번호 = B.고객번호

FROM 안에 SELECT .. > 서브쿼리 (인라인뷰)
WHERE 안에 SELECT .. > 서브쿼리

### 서브쿼리 : 출력되는 행의 갯수에 따라 단일행 서브쿼리 / 다중행 서브쿼리

다중행 서브쿼리 예시 )  
SELECT COUNT(\*)  
FROM 고객목록  
WHERE 고객번호 NOT IN _(SELECT 고객번호 FROM 연체자목록)_

단일행 서브쿼리 예시 )  
SELECT _(SELECT SUM(salary) FROM 급여 WHERE EXTRACT(YEAR FROM 급여지급일) = 2021)_

### (Q) 다음 보기 중 서브쿼리에 대한 설명으로 옳은 것은 ?

보기 1) 서브쿼리에서는 정렬을 수행하는 ORDER BY를 사용할 수 있다.  
보기 2) 여러 행을 반환하는 서브쿼리는 단일행 연산자를 사용해야 한다.  
보기 3) 메인 쿼리에서 서브쿼리의 컬럼을 자유롭게 사용할 수 있다.  
보기 4) EXIST가 반환하는 결과값은 TRUE 혹은 FALSE 이다.

정답 : 4번

추가설명  
보기 1) 서브쿼리에 ORDER BY 사용 X (사용 못 하고, 사용 할 필요도 없음)  
보기 2) 다중행 연산자 사용  
보기 3) 메인쿼리가 서브쿼리의 컬럼 사용 X, (서브쿼리는 메인쿼리의 컬럼 사용 가능)  
보기 4) 결과가 하나라도 존재하면 TRUE

### 메인쿼리의 결과와 서브쿼리의 결과가 모두 동일할 때 참이되는 다중행 연산자는 ?

정답 : ALL

### 다중행 연산자 (IN, ALL/ANY, EXISTS)

- IN

  - 서브쿼리의 결과와 하나라도 일치하면 참

- ALL

  - 모든 조건을 만족해야 참
    e.g. 50000 > ALL(20000, 30000)  
    50000이 20000과 30000보다 큰가 ? 큼 TRUE

  e.g. 50000 > ALL(70000, 30000)  
  50000이 70000과 30000보다 큰가 ? 70000보다 작음 FALSE

- ANY

  - 조건 하나만 만족해도 참
    e.g. 50000 > ANY(70000, 30000)  
    50000이 70000 혹은 30000보다 큰가 ? 30000보다 큼 TRUE

- EXISTS
  - 결과가 하나라도 존재하면 참

# 계층형 조회 - 트리 형태의 데이터에 대해 조회를 수행하는 것

Lv 1 . 루트노드 : 계층구조 시작점 (START WITH로 시작)
Lv 2 ~ Lv 6. 자식노드
Lv 6 . LEAF 노트 (자식노드가 없는 데이터)

### (Q) 계층형 조회 : 아래의 SQL을 수행한 결과 첫 번째 행의 값을 기입하시오.

주어진 테이블

| col1 | col2 | col3 |
| :--: | :--: | :--: |
|  11  |      |  10  |
|  12  |  11  |  12  |
|  13  |  11  |  13  |
|  14  |  12  |  15  |

주어진 SQL 문 >  
SELECT col3  
FROM 조직구조  
START WITH col2 IS NULL  
CONNECT BY PRIOR col1 = col2 => 해석 : col1의 이전 값이 col2
ORDER SIBLINGS BY col3 ;

정답 : 15

> 계층형 조회문제는 조회를 통해 어떻게 레코드가 재배치되는지 파악하는 것이 중요  
> 동일한 값을 가진 컬럼끼리 연결되며 재배치 됨

계층형 조회 문제풀이 과정 >>

| 레코드명 | col1 | col2 | col3 |
| :------: | :--: | :--: | :--: |
|    ㄱ    |  11  |      |  10  |
|    ㄴ    |  12  |  11  |  12  |
|    ㄷ    |  13  |  11  |  13  |
|    ㄹ    |  14  |  12  |  15  |

| ㄱ | 11 | | 10 | => START WITH (루트노드)

| 레코드명 | col1 | col2 | col3 |
| :------: | :--: | :--: | :--: |
|    ㄱ    |  11  |      |  10  |

| 레코드명 | col1 | col2 | col3 |
| :------: | :--: | :--: | :--: |
|    ㄴ    |  12  |  11  |  12  |
|    ㄷ    |  13  |  11  |  13  |
|    ㄱ    |  11  |      |  10  |

재배치 최종 결과

| 레코드명 | col1 | col2 | col3 |
| :------: | :--: | :--: | :--: |
|    ㄹ    |  14  |  12  |  15  |
|    ㄴ    |  12  |  11  |  12  |
|    ㄷ    |  13  |  11  |  13  |
|    ㄱ    |  11  |      |  10  |
